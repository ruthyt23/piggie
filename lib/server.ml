open! Core
open! Async
open! Fzf
open! Import

(* Generates player id for next queued player *)
module Player_id_manager = struct
  type t = int ref

  let create () = ref 0

  let next_id t =
    let this_id = !t in
    incr t;
    this_id
  ;;
end

module Game_manager = struct
  type t = { mutable game_opt : Game.t option }

  let create () = { game_opt = None }
end

let queue_of_player_names = Queue.create ()
let player_id_manager = Player_id_manager.create ()
let game_manager = Game_manager.create ()

let waiting_handle (_client : unit) (query : Rpcs.Waiting_room.Query.t) =
  Queue.enqueue queue_of_player_names query;
  let new_player_id = Player_id_manager.next_id player_id_manager in
  printf
    "%s has joined the game and their player_id is %d \n"
    query
    new_player_id;
  (* Start the game if we have the right number of players *)
  match equal (Queue.length queue_of_player_names) 3 with
  | false -> Deferred.return new_player_id
  | true ->
    (* There is definitely a bug with player_ids *)
    (* After the first game, the ids generated by player_id generator and the
       the id in the actual game dont match *)
    (* We need to start the game with a (name * id) list to ensure the id in
       the game is the same as the id the user thinks they have*)
    let list_of_player_names = Queue.to_list queue_of_player_names in
    let game = Game.create_game_from_names list_of_player_names in
    game_manager.game_opt <- Some game;
    Deferred.return new_player_id
;;

let game_data_handle (_client : unit) (query : Rpcs.Game_data.Query.t) =
  (* Wait until three players, then send in the game_data *)
  match game_manager.game_opt with
  | None -> return Rpcs.Game_data.Response.Waiting
  | Some game ->
    let winning_players = Game.check_for_wins game in
    (match Int.(List.length winning_players >= 1) with
     | true -> return (Rpcs.Game_data.Response.Game_over winning_players)
     | false ->
       let player_hand = Game.get_hand_for_player game query in
       return (Rpcs.Game_data.Response.In_progress player_hand))
;;

let make_trade_handle (_client : unit) (query : Rpcs.Make_trade.Query.t) =
  Deferred.return 1
;;

let implementations =
  Rpc.Implementations.create_exn
    ~on_unknown_rpc:`Close_connection
    ~implementations:
      [ Rpc.Rpc.implement Rpcs.Waiting_room.rpc waiting_handle
      ; Rpc.Rpc.implement Rpcs.Game_data.rpc game_data_handle
        (* Rpc.Rpc.implement Rpcs.Make_trade.rpc make_trade_handle *)
      ]
;;

let start_game =
  Command.async
    ~summary:"Play"
    (let%map_open.Command () = return ()
     and port = flag "-port" (required int) ~doc:"_ port to listen\n   on" in
     fun () ->
       let%bind server =
         Rpc.Connection.serve
           ~implementations
           ~initial_connection_state:(fun _client_identity _client_addr ->
             (* This constructs the "client" values which are passed to the
                implementation function above. We're just using unit for
                now. *)
             ())
           ~where_to_listen:(Tcp.Where_to_listen.of_port port)
           ()
       in
       Tcp.Server.close_finished server)
;;
